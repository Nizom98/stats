package stats

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_models "github.com/Nizom98/stats/internal/models"
	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements models.StatsRepository
type RepositoryMock struct {
	t minimock.Tester

	funcActivated          func()
	inspectFuncActivated   func()
	afterActivatedCounter  uint64
	beforeActivatedCounter uint64
	ActivatedMock          mRepositoryMockActivated

	funcDeactivated          func()
	inspectFuncDeactivated   func()
	afterDeactivatedCounter  uint64
	beforeDeactivatedCounter uint64
	DeactivatedMock          mRepositoryMockDeactivated

	funcDeposited          func(amount float64)
	inspectFuncDeposited   func(amount float64)
	afterDepositedCounter  uint64
	beforeDepositedCounter uint64
	DepositedMock          mRepositoryMockDeposited

	funcIncTotal          func()
	inspectFuncIncTotal   func()
	afterIncTotalCounter  uint64
	beforeIncTotalCounter uint64
	IncTotalMock          mRepositoryMockIncTotal

	funcStats          func() (s1 mm_models.Stats)
	inspectFuncStats   func()
	afterStatsCounter  uint64
	beforeStatsCounter uint64
	StatsMock          mRepositoryMockStats

	funcTransaction          func(fn func(repo mm_models.StatsRepository) error) (err error)
	inspectFuncTransaction   func(fn func(repo mm_models.StatsRepository) error)
	afterTransactionCounter  uint64
	beforeTransactionCounter uint64
	TransactionMock          mRepositoryMockTransaction

	funcTransfered          func(amount float64)
	inspectFuncTransfered   func(amount float64)
	afterTransferedCounter  uint64
	beforeTransferedCounter uint64
	TransferedMock          mRepositoryMockTransfered

	funcWithdrawn          func(amount float64)
	inspectFuncWithdrawn   func(amount float64)
	afterWithdrawnCounter  uint64
	beforeWithdrawnCounter uint64
	WithdrawnMock          mRepositoryMockWithdrawn
}

// NewRepositoryMock returns a mock for models.StatsRepository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ActivatedMock = mRepositoryMockActivated{mock: m}

	m.DeactivatedMock = mRepositoryMockDeactivated{mock: m}

	m.DepositedMock = mRepositoryMockDeposited{mock: m}
	m.DepositedMock.callArgs = []*RepositoryMockDepositedParams{}

	m.IncTotalMock = mRepositoryMockIncTotal{mock: m}

	m.StatsMock = mRepositoryMockStats{mock: m}

	m.TransactionMock = mRepositoryMockTransaction{mock: m}
	m.TransactionMock.callArgs = []*RepositoryMockTransactionParams{}

	m.TransferedMock = mRepositoryMockTransfered{mock: m}
	m.TransferedMock.callArgs = []*RepositoryMockTransferedParams{}

	m.WithdrawnMock = mRepositoryMockWithdrawn{mock: m}
	m.WithdrawnMock.callArgs = []*RepositoryMockWithdrawnParams{}

	return m
}

type mRepositoryMockActivated struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockActivatedExpectation
	expectations       []*RepositoryMockActivatedExpectation
}

// RepositoryMockActivatedExpectation specifies expectation struct of the StatsRepository.Activated
type RepositoryMockActivatedExpectation struct {
	mock *RepositoryMock

	Counter uint64
}

// Expect sets up expected params for StatsRepository.Activated
func (mmActivated *mRepositoryMockActivated) Expect() *mRepositoryMockActivated {
	if mmActivated.mock.funcActivated != nil {
		mmActivated.mock.t.Fatalf("RepositoryMock.Activated mock is already set by Set")
	}

	if mmActivated.defaultExpectation == nil {
		mmActivated.defaultExpectation = &RepositoryMockActivatedExpectation{}
	}

	return mmActivated
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Activated
func (mmActivated *mRepositoryMockActivated) Inspect(f func()) *mRepositoryMockActivated {
	if mmActivated.mock.inspectFuncActivated != nil {
		mmActivated.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Activated")
	}

	mmActivated.mock.inspectFuncActivated = f

	return mmActivated
}

// Return sets up results that will be returned by StatsRepository.Activated
func (mmActivated *mRepositoryMockActivated) Return() *RepositoryMock {
	if mmActivated.mock.funcActivated != nil {
		mmActivated.mock.t.Fatalf("RepositoryMock.Activated mock is already set by Set")
	}

	if mmActivated.defaultExpectation == nil {
		mmActivated.defaultExpectation = &RepositoryMockActivatedExpectation{mock: mmActivated.mock}
	}

	return mmActivated.mock
}

// Set uses given function f to mock the StatsRepository.Activated method
func (mmActivated *mRepositoryMockActivated) Set(f func()) *RepositoryMock {
	if mmActivated.defaultExpectation != nil {
		mmActivated.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Activated method")
	}

	if len(mmActivated.expectations) > 0 {
		mmActivated.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Activated method")
	}

	mmActivated.mock.funcActivated = f
	return mmActivated.mock
}

// Activated implements models.StatsRepository
func (mmActivated *RepositoryMock) Activated() {
	mm_atomic.AddUint64(&mmActivated.beforeActivatedCounter, 1)
	defer mm_atomic.AddUint64(&mmActivated.afterActivatedCounter, 1)

	if mmActivated.inspectFuncActivated != nil {
		mmActivated.inspectFuncActivated()
	}

	if mmActivated.ActivatedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmActivated.ActivatedMock.defaultExpectation.Counter, 1)

		return

	}
	if mmActivated.funcActivated != nil {
		mmActivated.funcActivated()
		return
	}
	mmActivated.t.Fatalf("Unexpected call to RepositoryMock.Activated.")

}

// ActivatedAfterCounter returns a count of finished RepositoryMock.Activated invocations
func (mmActivated *RepositoryMock) ActivatedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivated.afterActivatedCounter)
}

// ActivatedBeforeCounter returns a count of RepositoryMock.Activated invocations
func (mmActivated *RepositoryMock) ActivatedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivated.beforeActivatedCounter)
}

// MinimockActivatedDone returns true if the count of the Activated invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockActivatedDone() bool {
	for _, e := range m.ActivatedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivatedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivatedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivated != nil && mm_atomic.LoadUint64(&m.afterActivatedCounter) < 1 {
		return false
	}
	return true
}

// MinimockActivatedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockActivatedInspect() {
	for _, e := range m.ActivatedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Activated")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivatedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivatedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Activated")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivated != nil && mm_atomic.LoadUint64(&m.afterActivatedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Activated")
	}
}

type mRepositoryMockDeactivated struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeactivatedExpectation
	expectations       []*RepositoryMockDeactivatedExpectation
}

// RepositoryMockDeactivatedExpectation specifies expectation struct of the StatsRepository.Deactivated
type RepositoryMockDeactivatedExpectation struct {
	mock *RepositoryMock

	Counter uint64
}

// Expect sets up expected params for StatsRepository.Deactivated
func (mmDeactivated *mRepositoryMockDeactivated) Expect() *mRepositoryMockDeactivated {
	if mmDeactivated.mock.funcDeactivated != nil {
		mmDeactivated.mock.t.Fatalf("RepositoryMock.Deactivated mock is already set by Set")
	}

	if mmDeactivated.defaultExpectation == nil {
		mmDeactivated.defaultExpectation = &RepositoryMockDeactivatedExpectation{}
	}

	return mmDeactivated
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Deactivated
func (mmDeactivated *mRepositoryMockDeactivated) Inspect(f func()) *mRepositoryMockDeactivated {
	if mmDeactivated.mock.inspectFuncDeactivated != nil {
		mmDeactivated.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Deactivated")
	}

	mmDeactivated.mock.inspectFuncDeactivated = f

	return mmDeactivated
}

// Return sets up results that will be returned by StatsRepository.Deactivated
func (mmDeactivated *mRepositoryMockDeactivated) Return() *RepositoryMock {
	if mmDeactivated.mock.funcDeactivated != nil {
		mmDeactivated.mock.t.Fatalf("RepositoryMock.Deactivated mock is already set by Set")
	}

	if mmDeactivated.defaultExpectation == nil {
		mmDeactivated.defaultExpectation = &RepositoryMockDeactivatedExpectation{mock: mmDeactivated.mock}
	}

	return mmDeactivated.mock
}

// Set uses given function f to mock the StatsRepository.Deactivated method
func (mmDeactivated *mRepositoryMockDeactivated) Set(f func()) *RepositoryMock {
	if mmDeactivated.defaultExpectation != nil {
		mmDeactivated.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Deactivated method")
	}

	if len(mmDeactivated.expectations) > 0 {
		mmDeactivated.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Deactivated method")
	}

	mmDeactivated.mock.funcDeactivated = f
	return mmDeactivated.mock
}

// Deactivated implements models.StatsRepository
func (mmDeactivated *RepositoryMock) Deactivated() {
	mm_atomic.AddUint64(&mmDeactivated.beforeDeactivatedCounter, 1)
	defer mm_atomic.AddUint64(&mmDeactivated.afterDeactivatedCounter, 1)

	if mmDeactivated.inspectFuncDeactivated != nil {
		mmDeactivated.inspectFuncDeactivated()
	}

	if mmDeactivated.DeactivatedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeactivated.DeactivatedMock.defaultExpectation.Counter, 1)

		return

	}
	if mmDeactivated.funcDeactivated != nil {
		mmDeactivated.funcDeactivated()
		return
	}
	mmDeactivated.t.Fatalf("Unexpected call to RepositoryMock.Deactivated.")

}

// DeactivatedAfterCounter returns a count of finished RepositoryMock.Deactivated invocations
func (mmDeactivated *RepositoryMock) DeactivatedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeactivated.afterDeactivatedCounter)
}

// DeactivatedBeforeCounter returns a count of RepositoryMock.Deactivated invocations
func (mmDeactivated *RepositoryMock) DeactivatedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeactivated.beforeDeactivatedCounter)
}

// MinimockDeactivatedDone returns true if the count of the Deactivated invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeactivatedDone() bool {
	for _, e := range m.DeactivatedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeactivatedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeactivatedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeactivated != nil && mm_atomic.LoadUint64(&m.afterDeactivatedCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeactivatedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeactivatedInspect() {
	for _, e := range m.DeactivatedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Deactivated")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeactivatedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeactivatedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Deactivated")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeactivated != nil && mm_atomic.LoadUint64(&m.afterDeactivatedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Deactivated")
	}
}

type mRepositoryMockDeposited struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDepositedExpectation
	expectations       []*RepositoryMockDepositedExpectation

	callArgs []*RepositoryMockDepositedParams
	mutex    sync.RWMutex
}

// RepositoryMockDepositedExpectation specifies expectation struct of the StatsRepository.Deposited
type RepositoryMockDepositedExpectation struct {
	mock   *RepositoryMock
	params *RepositoryMockDepositedParams

	Counter uint64
}

// RepositoryMockDepositedParams contains parameters of the StatsRepository.Deposited
type RepositoryMockDepositedParams struct {
	amount float64
}

// Expect sets up expected params for StatsRepository.Deposited
func (mmDeposited *mRepositoryMockDeposited) Expect(amount float64) *mRepositoryMockDeposited {
	if mmDeposited.mock.funcDeposited != nil {
		mmDeposited.mock.t.Fatalf("RepositoryMock.Deposited mock is already set by Set")
	}

	if mmDeposited.defaultExpectation == nil {
		mmDeposited.defaultExpectation = &RepositoryMockDepositedExpectation{}
	}

	mmDeposited.defaultExpectation.params = &RepositoryMockDepositedParams{amount}
	for _, e := range mmDeposited.expectations {
		if minimock.Equal(e.params, mmDeposited.defaultExpectation.params) {
			mmDeposited.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeposited.defaultExpectation.params)
		}
	}

	return mmDeposited
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Deposited
func (mmDeposited *mRepositoryMockDeposited) Inspect(f func(amount float64)) *mRepositoryMockDeposited {
	if mmDeposited.mock.inspectFuncDeposited != nil {
		mmDeposited.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Deposited")
	}

	mmDeposited.mock.inspectFuncDeposited = f

	return mmDeposited
}

// Return sets up results that will be returned by StatsRepository.Deposited
func (mmDeposited *mRepositoryMockDeposited) Return() *RepositoryMock {
	if mmDeposited.mock.funcDeposited != nil {
		mmDeposited.mock.t.Fatalf("RepositoryMock.Deposited mock is already set by Set")
	}

	if mmDeposited.defaultExpectation == nil {
		mmDeposited.defaultExpectation = &RepositoryMockDepositedExpectation{mock: mmDeposited.mock}
	}

	return mmDeposited.mock
}

// Set uses given function f to mock the StatsRepository.Deposited method
func (mmDeposited *mRepositoryMockDeposited) Set(f func(amount float64)) *RepositoryMock {
	if mmDeposited.defaultExpectation != nil {
		mmDeposited.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Deposited method")
	}

	if len(mmDeposited.expectations) > 0 {
		mmDeposited.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Deposited method")
	}

	mmDeposited.mock.funcDeposited = f
	return mmDeposited.mock
}

// Deposited implements models.StatsRepository
func (mmDeposited *RepositoryMock) Deposited(amount float64) {
	mm_atomic.AddUint64(&mmDeposited.beforeDepositedCounter, 1)
	defer mm_atomic.AddUint64(&mmDeposited.afterDepositedCounter, 1)

	if mmDeposited.inspectFuncDeposited != nil {
		mmDeposited.inspectFuncDeposited(amount)
	}

	mm_params := &RepositoryMockDepositedParams{amount}

	// Record call args
	mmDeposited.DepositedMock.mutex.Lock()
	mmDeposited.DepositedMock.callArgs = append(mmDeposited.DepositedMock.callArgs, mm_params)
	mmDeposited.DepositedMock.mutex.Unlock()

	for _, e := range mmDeposited.DepositedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeposited.DepositedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeposited.DepositedMock.defaultExpectation.Counter, 1)
		mm_want := mmDeposited.DepositedMock.defaultExpectation.params
		mm_got := RepositoryMockDepositedParams{amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeposited.t.Errorf("RepositoryMock.Deposited got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeposited.funcDeposited != nil {
		mmDeposited.funcDeposited(amount)
		return
	}
	mmDeposited.t.Fatalf("Unexpected call to RepositoryMock.Deposited. %v", amount)

}

// DepositedAfterCounter returns a count of finished RepositoryMock.Deposited invocations
func (mmDeposited *RepositoryMock) DepositedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeposited.afterDepositedCounter)
}

// DepositedBeforeCounter returns a count of RepositoryMock.Deposited invocations
func (mmDeposited *RepositoryMock) DepositedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeposited.beforeDepositedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Deposited.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeposited *mRepositoryMockDeposited) Calls() []*RepositoryMockDepositedParams {
	mmDeposited.mutex.RLock()

	argCopy := make([]*RepositoryMockDepositedParams, len(mmDeposited.callArgs))
	copy(argCopy, mmDeposited.callArgs)

	mmDeposited.mutex.RUnlock()

	return argCopy
}

// MinimockDepositedDone returns true if the count of the Deposited invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDepositedDone() bool {
	for _, e := range m.DepositedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DepositedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDepositedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeposited != nil && mm_atomic.LoadUint64(&m.afterDepositedCounter) < 1 {
		return false
	}
	return true
}

// MinimockDepositedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDepositedInspect() {
	for _, e := range m.DepositedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Deposited with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DepositedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDepositedCounter) < 1 {
		if m.DepositedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Deposited")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Deposited with params: %#v", *m.DepositedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeposited != nil && mm_atomic.LoadUint64(&m.afterDepositedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Deposited")
	}
}

type mRepositoryMockIncTotal struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockIncTotalExpectation
	expectations       []*RepositoryMockIncTotalExpectation
}

// RepositoryMockIncTotalExpectation specifies expectation struct of the StatsRepository.IncTotal
type RepositoryMockIncTotalExpectation struct {
	mock *RepositoryMock

	Counter uint64
}

// Expect sets up expected params for StatsRepository.IncTotal
func (mmIncTotal *mRepositoryMockIncTotal) Expect() *mRepositoryMockIncTotal {
	if mmIncTotal.mock.funcIncTotal != nil {
		mmIncTotal.mock.t.Fatalf("RepositoryMock.IncTotal mock is already set by Set")
	}

	if mmIncTotal.defaultExpectation == nil {
		mmIncTotal.defaultExpectation = &RepositoryMockIncTotalExpectation{}
	}

	return mmIncTotal
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.IncTotal
func (mmIncTotal *mRepositoryMockIncTotal) Inspect(f func()) *mRepositoryMockIncTotal {
	if mmIncTotal.mock.inspectFuncIncTotal != nil {
		mmIncTotal.mock.t.Fatalf("Inspect function is already set for RepositoryMock.IncTotal")
	}

	mmIncTotal.mock.inspectFuncIncTotal = f

	return mmIncTotal
}

// Return sets up results that will be returned by StatsRepository.IncTotal
func (mmIncTotal *mRepositoryMockIncTotal) Return() *RepositoryMock {
	if mmIncTotal.mock.funcIncTotal != nil {
		mmIncTotal.mock.t.Fatalf("RepositoryMock.IncTotal mock is already set by Set")
	}

	if mmIncTotal.defaultExpectation == nil {
		mmIncTotal.defaultExpectation = &RepositoryMockIncTotalExpectation{mock: mmIncTotal.mock}
	}

	return mmIncTotal.mock
}

// Set uses given function f to mock the StatsRepository.IncTotal method
func (mmIncTotal *mRepositoryMockIncTotal) Set(f func()) *RepositoryMock {
	if mmIncTotal.defaultExpectation != nil {
		mmIncTotal.mock.t.Fatalf("Default expectation is already set for the StatsRepository.IncTotal method")
	}

	if len(mmIncTotal.expectations) > 0 {
		mmIncTotal.mock.t.Fatalf("Some expectations are already set for the StatsRepository.IncTotal method")
	}

	mmIncTotal.mock.funcIncTotal = f
	return mmIncTotal.mock
}

// IncTotal implements models.StatsRepository
func (mmIncTotal *RepositoryMock) IncTotal() {
	mm_atomic.AddUint64(&mmIncTotal.beforeIncTotalCounter, 1)
	defer mm_atomic.AddUint64(&mmIncTotal.afterIncTotalCounter, 1)

	if mmIncTotal.inspectFuncIncTotal != nil {
		mmIncTotal.inspectFuncIncTotal()
	}

	if mmIncTotal.IncTotalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncTotal.IncTotalMock.defaultExpectation.Counter, 1)

		return

	}
	if mmIncTotal.funcIncTotal != nil {
		mmIncTotal.funcIncTotal()
		return
	}
	mmIncTotal.t.Fatalf("Unexpected call to RepositoryMock.IncTotal.")

}

// IncTotalAfterCounter returns a count of finished RepositoryMock.IncTotal invocations
func (mmIncTotal *RepositoryMock) IncTotalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncTotal.afterIncTotalCounter)
}

// IncTotalBeforeCounter returns a count of RepositoryMock.IncTotal invocations
func (mmIncTotal *RepositoryMock) IncTotalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncTotal.beforeIncTotalCounter)
}

// MinimockIncTotalDone returns true if the count of the IncTotal invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockIncTotalDone() bool {
	for _, e := range m.IncTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncTotalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncTotalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncTotal != nil && mm_atomic.LoadUint64(&m.afterIncTotalCounter) < 1 {
		return false
	}
	return true
}

// MinimockIncTotalInspect logs each unmet expectation
func (m *RepositoryMock) MinimockIncTotalInspect() {
	for _, e := range m.IncTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.IncTotal")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncTotalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncTotalCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.IncTotal")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncTotal != nil && mm_atomic.LoadUint64(&m.afterIncTotalCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.IncTotal")
	}
}

type mRepositoryMockStats struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockStatsExpectation
	expectations       []*RepositoryMockStatsExpectation
}

// RepositoryMockStatsExpectation specifies expectation struct of the StatsRepository.Stats
type RepositoryMockStatsExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockStatsResults
	Counter uint64
}

// RepositoryMockStatsResults contains results of the StatsRepository.Stats
type RepositoryMockStatsResults struct {
	s1 mm_models.Stats
}

// Expect sets up expected params for StatsRepository.Stats
func (mmStats *mRepositoryMockStats) Expect() *mRepositoryMockStats {
	if mmStats.mock.funcStats != nil {
		mmStats.mock.t.Fatalf("RepositoryMock.Stats mock is already set by Set")
	}

	if mmStats.defaultExpectation == nil {
		mmStats.defaultExpectation = &RepositoryMockStatsExpectation{}
	}

	return mmStats
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Stats
func (mmStats *mRepositoryMockStats) Inspect(f func()) *mRepositoryMockStats {
	if mmStats.mock.inspectFuncStats != nil {
		mmStats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Stats")
	}

	mmStats.mock.inspectFuncStats = f

	return mmStats
}

// Return sets up results that will be returned by StatsRepository.Stats
func (mmStats *mRepositoryMockStats) Return(s1 mm_models.Stats) *RepositoryMock {
	if mmStats.mock.funcStats != nil {
		mmStats.mock.t.Fatalf("RepositoryMock.Stats mock is already set by Set")
	}

	if mmStats.defaultExpectation == nil {
		mmStats.defaultExpectation = &RepositoryMockStatsExpectation{mock: mmStats.mock}
	}
	mmStats.defaultExpectation.results = &RepositoryMockStatsResults{s1}
	return mmStats.mock
}

// Set uses given function f to mock the StatsRepository.Stats method
func (mmStats *mRepositoryMockStats) Set(f func() (s1 mm_models.Stats)) *RepositoryMock {
	if mmStats.defaultExpectation != nil {
		mmStats.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Stats method")
	}

	if len(mmStats.expectations) > 0 {
		mmStats.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Stats method")
	}

	mmStats.mock.funcStats = f
	return mmStats.mock
}

// Stats implements models.StatsRepository
func (mmStats *RepositoryMock) Stats() (s1 mm_models.Stats) {
	mm_atomic.AddUint64(&mmStats.beforeStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmStats.afterStatsCounter, 1)

	if mmStats.inspectFuncStats != nil {
		mmStats.inspectFuncStats()
	}

	if mmStats.StatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStats.StatsMock.defaultExpectation.Counter, 1)

		mm_results := mmStats.StatsMock.defaultExpectation.results
		if mm_results == nil {
			mmStats.t.Fatal("No results are set for the RepositoryMock.Stats")
		}
		return (*mm_results).s1
	}
	if mmStats.funcStats != nil {
		return mmStats.funcStats()
	}
	mmStats.t.Fatalf("Unexpected call to RepositoryMock.Stats.")
	return
}

// StatsAfterCounter returns a count of finished RepositoryMock.Stats invocations
func (mmStats *RepositoryMock) StatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStats.afterStatsCounter)
}

// StatsBeforeCounter returns a count of RepositoryMock.Stats invocations
func (mmStats *RepositoryMock) StatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStats.beforeStatsCounter)
}

// MinimockStatsDone returns true if the count of the Stats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockStatsDone() bool {
	for _, e := range m.StatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStats != nil && mm_atomic.LoadUint64(&m.afterStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockStatsInspect() {
	for _, e := range m.StatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Stats")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Stats")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStats != nil && mm_atomic.LoadUint64(&m.afterStatsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Stats")
	}
}

type mRepositoryMockTransaction struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTransactionExpectation
	expectations       []*RepositoryMockTransactionExpectation

	callArgs []*RepositoryMockTransactionParams
	mutex    sync.RWMutex
}

// RepositoryMockTransactionExpectation specifies expectation struct of the StatsRepository.Transaction
type RepositoryMockTransactionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockTransactionParams
	results *RepositoryMockTransactionResults
	Counter uint64
}

// RepositoryMockTransactionParams contains parameters of the StatsRepository.Transaction
type RepositoryMockTransactionParams struct {
	fn func(repo mm_models.StatsRepository) error
}

// RepositoryMockTransactionResults contains results of the StatsRepository.Transaction
type RepositoryMockTransactionResults struct {
	err error
}

// Expect sets up expected params for StatsRepository.Transaction
func (mmTransaction *mRepositoryMockTransaction) Expect(fn func(repo mm_models.StatsRepository) error) *mRepositoryMockTransaction {
	if mmTransaction.mock.funcTransaction != nil {
		mmTransaction.mock.t.Fatalf("RepositoryMock.Transaction mock is already set by Set")
	}

	if mmTransaction.defaultExpectation == nil {
		mmTransaction.defaultExpectation = &RepositoryMockTransactionExpectation{}
	}

	mmTransaction.defaultExpectation.params = &RepositoryMockTransactionParams{fn}
	for _, e := range mmTransaction.expectations {
		if minimock.Equal(e.params, mmTransaction.defaultExpectation.params) {
			mmTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTransaction.defaultExpectation.params)
		}
	}

	return mmTransaction
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Transaction
func (mmTransaction *mRepositoryMockTransaction) Inspect(f func(fn func(repo mm_models.StatsRepository) error)) *mRepositoryMockTransaction {
	if mmTransaction.mock.inspectFuncTransaction != nil {
		mmTransaction.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Transaction")
	}

	mmTransaction.mock.inspectFuncTransaction = f

	return mmTransaction
}

// Return sets up results that will be returned by StatsRepository.Transaction
func (mmTransaction *mRepositoryMockTransaction) Return(err error) *RepositoryMock {
	if mmTransaction.mock.funcTransaction != nil {
		mmTransaction.mock.t.Fatalf("RepositoryMock.Transaction mock is already set by Set")
	}

	if mmTransaction.defaultExpectation == nil {
		mmTransaction.defaultExpectation = &RepositoryMockTransactionExpectation{mock: mmTransaction.mock}
	}
	mmTransaction.defaultExpectation.results = &RepositoryMockTransactionResults{err}
	return mmTransaction.mock
}

// Set uses given function f to mock the StatsRepository.Transaction method
func (mmTransaction *mRepositoryMockTransaction) Set(f func(fn func(repo mm_models.StatsRepository) error) (err error)) *RepositoryMock {
	if mmTransaction.defaultExpectation != nil {
		mmTransaction.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Transaction method")
	}

	if len(mmTransaction.expectations) > 0 {
		mmTransaction.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Transaction method")
	}

	mmTransaction.mock.funcTransaction = f
	return mmTransaction.mock
}

// When sets expectation for the StatsRepository.Transaction which will trigger the result defined by the following
// Then helper
func (mmTransaction *mRepositoryMockTransaction) When(fn func(repo mm_models.StatsRepository) error) *RepositoryMockTransactionExpectation {
	if mmTransaction.mock.funcTransaction != nil {
		mmTransaction.mock.t.Fatalf("RepositoryMock.Transaction mock is already set by Set")
	}

	expectation := &RepositoryMockTransactionExpectation{
		mock:   mmTransaction.mock,
		params: &RepositoryMockTransactionParams{fn},
	}
	mmTransaction.expectations = append(mmTransaction.expectations, expectation)
	return expectation
}

// Then sets up StatsRepository.Transaction return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTransactionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockTransactionResults{err}
	return e.mock
}

// Transaction implements models.StatsRepository
func (mmTransaction *RepositoryMock) Transaction(fn func(repo mm_models.StatsRepository) error) (err error) {
	mm_atomic.AddUint64(&mmTransaction.beforeTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmTransaction.afterTransactionCounter, 1)

	if mmTransaction.inspectFuncTransaction != nil {
		mmTransaction.inspectFuncTransaction(fn)
	}

	mm_params := &RepositoryMockTransactionParams{fn}

	// Record call args
	mmTransaction.TransactionMock.mutex.Lock()
	mmTransaction.TransactionMock.callArgs = append(mmTransaction.TransactionMock.callArgs, mm_params)
	mmTransaction.TransactionMock.mutex.Unlock()

	for _, e := range mmTransaction.TransactionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTransaction.TransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTransaction.TransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmTransaction.TransactionMock.defaultExpectation.params
		mm_got := RepositoryMockTransactionParams{fn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTransaction.t.Errorf("RepositoryMock.Transaction got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTransaction.TransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmTransaction.t.Fatal("No results are set for the RepositoryMock.Transaction")
		}
		return (*mm_results).err
	}
	if mmTransaction.funcTransaction != nil {
		return mmTransaction.funcTransaction(fn)
	}
	mmTransaction.t.Fatalf("Unexpected call to RepositoryMock.Transaction. %v", fn)
	return
}

// TransactionAfterCounter returns a count of finished RepositoryMock.Transaction invocations
func (mmTransaction *RepositoryMock) TransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransaction.afterTransactionCounter)
}

// TransactionBeforeCounter returns a count of RepositoryMock.Transaction invocations
func (mmTransaction *RepositoryMock) TransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransaction.beforeTransactionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Transaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTransaction *mRepositoryMockTransaction) Calls() []*RepositoryMockTransactionParams {
	mmTransaction.mutex.RLock()

	argCopy := make([]*RepositoryMockTransactionParams, len(mmTransaction.callArgs))
	copy(argCopy, mmTransaction.callArgs)

	mmTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockTransactionDone returns true if the count of the Transaction invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTransactionDone() bool {
	for _, e := range m.TransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransaction != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		return false
	}
	return true
}

// MinimockTransactionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTransactionInspect() {
	for _, e := range m.TransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Transaction with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		if m.TransactionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Transaction")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Transaction with params: %#v", *m.TransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransaction != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Transaction")
	}
}

type mRepositoryMockTransfered struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTransferedExpectation
	expectations       []*RepositoryMockTransferedExpectation

	callArgs []*RepositoryMockTransferedParams
	mutex    sync.RWMutex
}

// RepositoryMockTransferedExpectation specifies expectation struct of the StatsRepository.Transfered
type RepositoryMockTransferedExpectation struct {
	mock   *RepositoryMock
	params *RepositoryMockTransferedParams

	Counter uint64
}

// RepositoryMockTransferedParams contains parameters of the StatsRepository.Transfered
type RepositoryMockTransferedParams struct {
	amount float64
}

// Expect sets up expected params for StatsRepository.Transfered
func (mmTransfered *mRepositoryMockTransfered) Expect(amount float64) *mRepositoryMockTransfered {
	if mmTransfered.mock.funcTransfered != nil {
		mmTransfered.mock.t.Fatalf("RepositoryMock.Transfered mock is already set by Set")
	}

	if mmTransfered.defaultExpectation == nil {
		mmTransfered.defaultExpectation = &RepositoryMockTransferedExpectation{}
	}

	mmTransfered.defaultExpectation.params = &RepositoryMockTransferedParams{amount}
	for _, e := range mmTransfered.expectations {
		if minimock.Equal(e.params, mmTransfered.defaultExpectation.params) {
			mmTransfered.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTransfered.defaultExpectation.params)
		}
	}

	return mmTransfered
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Transfered
func (mmTransfered *mRepositoryMockTransfered) Inspect(f func(amount float64)) *mRepositoryMockTransfered {
	if mmTransfered.mock.inspectFuncTransfered != nil {
		mmTransfered.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Transfered")
	}

	mmTransfered.mock.inspectFuncTransfered = f

	return mmTransfered
}

// Return sets up results that will be returned by StatsRepository.Transfered
func (mmTransfered *mRepositoryMockTransfered) Return() *RepositoryMock {
	if mmTransfered.mock.funcTransfered != nil {
		mmTransfered.mock.t.Fatalf("RepositoryMock.Transfered mock is already set by Set")
	}

	if mmTransfered.defaultExpectation == nil {
		mmTransfered.defaultExpectation = &RepositoryMockTransferedExpectation{mock: mmTransfered.mock}
	}

	return mmTransfered.mock
}

// Set uses given function f to mock the StatsRepository.Transfered method
func (mmTransfered *mRepositoryMockTransfered) Set(f func(amount float64)) *RepositoryMock {
	if mmTransfered.defaultExpectation != nil {
		mmTransfered.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Transfered method")
	}

	if len(mmTransfered.expectations) > 0 {
		mmTransfered.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Transfered method")
	}

	mmTransfered.mock.funcTransfered = f
	return mmTransfered.mock
}

// Transfered implements models.StatsRepository
func (mmTransfered *RepositoryMock) Transfered(amount float64) {
	mm_atomic.AddUint64(&mmTransfered.beforeTransferedCounter, 1)
	defer mm_atomic.AddUint64(&mmTransfered.afterTransferedCounter, 1)

	if mmTransfered.inspectFuncTransfered != nil {
		mmTransfered.inspectFuncTransfered(amount)
	}

	mm_params := &RepositoryMockTransferedParams{amount}

	// Record call args
	mmTransfered.TransferedMock.mutex.Lock()
	mmTransfered.TransferedMock.callArgs = append(mmTransfered.TransferedMock.callArgs, mm_params)
	mmTransfered.TransferedMock.mutex.Unlock()

	for _, e := range mmTransfered.TransferedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTransfered.TransferedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTransfered.TransferedMock.defaultExpectation.Counter, 1)
		mm_want := mmTransfered.TransferedMock.defaultExpectation.params
		mm_got := RepositoryMockTransferedParams{amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTransfered.t.Errorf("RepositoryMock.Transfered got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTransfered.funcTransfered != nil {
		mmTransfered.funcTransfered(amount)
		return
	}
	mmTransfered.t.Fatalf("Unexpected call to RepositoryMock.Transfered. %v", amount)

}

// TransferedAfterCounter returns a count of finished RepositoryMock.Transfered invocations
func (mmTransfered *RepositoryMock) TransferedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransfered.afterTransferedCounter)
}

// TransferedBeforeCounter returns a count of RepositoryMock.Transfered invocations
func (mmTransfered *RepositoryMock) TransferedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransfered.beforeTransferedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Transfered.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTransfered *mRepositoryMockTransfered) Calls() []*RepositoryMockTransferedParams {
	mmTransfered.mutex.RLock()

	argCopy := make([]*RepositoryMockTransferedParams, len(mmTransfered.callArgs))
	copy(argCopy, mmTransfered.callArgs)

	mmTransfered.mutex.RUnlock()

	return argCopy
}

// MinimockTransferedDone returns true if the count of the Transfered invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTransferedDone() bool {
	for _, e := range m.TransferedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransferedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransferedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransfered != nil && mm_atomic.LoadUint64(&m.afterTransferedCounter) < 1 {
		return false
	}
	return true
}

// MinimockTransferedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTransferedInspect() {
	for _, e := range m.TransferedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Transfered with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransferedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransferedCounter) < 1 {
		if m.TransferedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Transfered")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Transfered with params: %#v", *m.TransferedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransfered != nil && mm_atomic.LoadUint64(&m.afterTransferedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Transfered")
	}
}

type mRepositoryMockWithdrawn struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockWithdrawnExpectation
	expectations       []*RepositoryMockWithdrawnExpectation

	callArgs []*RepositoryMockWithdrawnParams
	mutex    sync.RWMutex
}

// RepositoryMockWithdrawnExpectation specifies expectation struct of the StatsRepository.Withdrawn
type RepositoryMockWithdrawnExpectation struct {
	mock   *RepositoryMock
	params *RepositoryMockWithdrawnParams

	Counter uint64
}

// RepositoryMockWithdrawnParams contains parameters of the StatsRepository.Withdrawn
type RepositoryMockWithdrawnParams struct {
	amount float64
}

// Expect sets up expected params for StatsRepository.Withdrawn
func (mmWithdrawn *mRepositoryMockWithdrawn) Expect(amount float64) *mRepositoryMockWithdrawn {
	if mmWithdrawn.mock.funcWithdrawn != nil {
		mmWithdrawn.mock.t.Fatalf("RepositoryMock.Withdrawn mock is already set by Set")
	}

	if mmWithdrawn.defaultExpectation == nil {
		mmWithdrawn.defaultExpectation = &RepositoryMockWithdrawnExpectation{}
	}

	mmWithdrawn.defaultExpectation.params = &RepositoryMockWithdrawnParams{amount}
	for _, e := range mmWithdrawn.expectations {
		if minimock.Equal(e.params, mmWithdrawn.defaultExpectation.params) {
			mmWithdrawn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithdrawn.defaultExpectation.params)
		}
	}

	return mmWithdrawn
}

// Inspect accepts an inspector function that has same arguments as the StatsRepository.Withdrawn
func (mmWithdrawn *mRepositoryMockWithdrawn) Inspect(f func(amount float64)) *mRepositoryMockWithdrawn {
	if mmWithdrawn.mock.inspectFuncWithdrawn != nil {
		mmWithdrawn.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Withdrawn")
	}

	mmWithdrawn.mock.inspectFuncWithdrawn = f

	return mmWithdrawn
}

// Return sets up results that will be returned by StatsRepository.Withdrawn
func (mmWithdrawn *mRepositoryMockWithdrawn) Return() *RepositoryMock {
	if mmWithdrawn.mock.funcWithdrawn != nil {
		mmWithdrawn.mock.t.Fatalf("RepositoryMock.Withdrawn mock is already set by Set")
	}

	if mmWithdrawn.defaultExpectation == nil {
		mmWithdrawn.defaultExpectation = &RepositoryMockWithdrawnExpectation{mock: mmWithdrawn.mock}
	}

	return mmWithdrawn.mock
}

// Set uses given function f to mock the StatsRepository.Withdrawn method
func (mmWithdrawn *mRepositoryMockWithdrawn) Set(f func(amount float64)) *RepositoryMock {
	if mmWithdrawn.defaultExpectation != nil {
		mmWithdrawn.mock.t.Fatalf("Default expectation is already set for the StatsRepository.Withdrawn method")
	}

	if len(mmWithdrawn.expectations) > 0 {
		mmWithdrawn.mock.t.Fatalf("Some expectations are already set for the StatsRepository.Withdrawn method")
	}

	mmWithdrawn.mock.funcWithdrawn = f
	return mmWithdrawn.mock
}

// Withdrawn implements models.StatsRepository
func (mmWithdrawn *RepositoryMock) Withdrawn(amount float64) {
	mm_atomic.AddUint64(&mmWithdrawn.beforeWithdrawnCounter, 1)
	defer mm_atomic.AddUint64(&mmWithdrawn.afterWithdrawnCounter, 1)

	if mmWithdrawn.inspectFuncWithdrawn != nil {
		mmWithdrawn.inspectFuncWithdrawn(amount)
	}

	mm_params := &RepositoryMockWithdrawnParams{amount}

	// Record call args
	mmWithdrawn.WithdrawnMock.mutex.Lock()
	mmWithdrawn.WithdrawnMock.callArgs = append(mmWithdrawn.WithdrawnMock.callArgs, mm_params)
	mmWithdrawn.WithdrawnMock.mutex.Unlock()

	for _, e := range mmWithdrawn.WithdrawnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWithdrawn.WithdrawnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithdrawn.WithdrawnMock.defaultExpectation.Counter, 1)
		mm_want := mmWithdrawn.WithdrawnMock.defaultExpectation.params
		mm_got := RepositoryMockWithdrawnParams{amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithdrawn.t.Errorf("RepositoryMock.Withdrawn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWithdrawn.funcWithdrawn != nil {
		mmWithdrawn.funcWithdrawn(amount)
		return
	}
	mmWithdrawn.t.Fatalf("Unexpected call to RepositoryMock.Withdrawn. %v", amount)

}

// WithdrawnAfterCounter returns a count of finished RepositoryMock.Withdrawn invocations
func (mmWithdrawn *RepositoryMock) WithdrawnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithdrawn.afterWithdrawnCounter)
}

// WithdrawnBeforeCounter returns a count of RepositoryMock.Withdrawn invocations
func (mmWithdrawn *RepositoryMock) WithdrawnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithdrawn.beforeWithdrawnCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Withdrawn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithdrawn *mRepositoryMockWithdrawn) Calls() []*RepositoryMockWithdrawnParams {
	mmWithdrawn.mutex.RLock()

	argCopy := make([]*RepositoryMockWithdrawnParams, len(mmWithdrawn.callArgs))
	copy(argCopy, mmWithdrawn.callArgs)

	mmWithdrawn.mutex.RUnlock()

	return argCopy
}

// MinimockWithdrawnDone returns true if the count of the Withdrawn invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockWithdrawnDone() bool {
	for _, e := range m.WithdrawnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithdrawnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithdrawnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithdrawn != nil && mm_atomic.LoadUint64(&m.afterWithdrawnCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithdrawnInspect logs each unmet expectation
func (m *RepositoryMock) MinimockWithdrawnInspect() {
	for _, e := range m.WithdrawnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Withdrawn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithdrawnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithdrawnCounter) < 1 {
		if m.WithdrawnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Withdrawn")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Withdrawn with params: %#v", *m.WithdrawnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithdrawn != nil && mm_atomic.LoadUint64(&m.afterWithdrawnCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Withdrawn")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockActivatedInspect()

		m.MinimockDeactivatedInspect()

		m.MinimockDepositedInspect()

		m.MinimockIncTotalInspect()

		m.MinimockStatsInspect()

		m.MinimockTransactionInspect()

		m.MinimockTransferedInspect()

		m.MinimockWithdrawnInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockActivatedDone() &&
		m.MinimockDeactivatedDone() &&
		m.MinimockDepositedDone() &&
		m.MinimockIncTotalDone() &&
		m.MinimockStatsDone() &&
		m.MinimockTransactionDone() &&
		m.MinimockTransferedDone() &&
		m.MinimockWithdrawnDone()
}
